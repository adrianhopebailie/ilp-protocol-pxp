import { EventEmitter } from 'events'
import * as http from 'http2'
import * as url from 'url'
import * as net from 'net'
import * as tls from 'tls'
import { IlpPrepare, IlpReply, Errors as IlpErrors, IlpReject } from 'ilp-packet'
import { SError } from 'verror'
import { IlpEndpoint, RequestHandlerProvider } from './endpoint'

export const DEFAULT_MAX_TIMEOUT_MS = 5 * 60 * 1000

/**
 * Constructor options for a new `IlpTransport` object.
 */
interface IlpTransportOptions {

  /**
   * The initial provider to use to provide a handler for incoming requests.
   */
  handlerProvider?: RequestHandlerProvider
  /**
   * The initial batch number to use
   */
  batch?: number
  /**
   * The time allowed after the batch changes when requests with the old batch will still be allowed.
   */
  batchCutoverTimeoutMs?: number
  /**
   * Max timeout allowed in ILP Prepare packets passed via `request`.
   */
  maxTimeoutMs?: number
}

interface IlpHttpEndpointOptions extends IlpTransportOptions {
  peerUrl: string | url.URL,
  clientOptions?: http.ClientSessionOptions | http.SecureClientSessionOptions,
  serverOptions: http.SecureServerOptions & { secure: boolean }
}

/**
 * Reference implementation of an IlpEndpoint using HTTP ILP as the underlying bilateral transport.
 */
export class IlpHttpEndpoint extends EventEmitter implements IlpEndpoint {
  protected _server: http.Http2Server
  protected _client: http.ClientHttp2Session
  protected _maxTimeoutMs: number

  /**
   * Create a new IlpTransport using the provided server and client as the underlying transports stream.
   *
   * @param options constructor options
   */
  constructor (options: IlpHttpEndpointOptions) {
    super()

    this._maxTimeoutMs = (options && options.maxTimeoutMs)
      ? options.maxTimeoutMs
      : DEFAULT_MAX_TIMEOUT_MS

    const createServer = options.serverOptions.secure ? http.createSecureServer : http.createServer
    this._server = createServer(options.serverOptions, this._handleRequest.bind(this))
    this._server.on('sessionError', (error: Error) => {
      this.emit('error', new SError('error in underlying session', error))
    })
    this._client = http.connect(options.peerUrl, options.clientOptions)

    if (options && options.handlerProvider) {
      this.handlerProvider = options.handlerProvider
    } else {
      this.handlerProvider = (packet: IlpPrepare) => {
        return (packet: IlpPrepare): Promise<IlpReply> => {
          const err = new SError('no request handler for incoming request', packet)
          this.emit('error', err)
          return Promise.resolve({
            triggeredBy: (this.address) ? this.address : 'peer',
            code: IlpErrors.codes.T00_INTERNAL_ERROR,
            message: '',
            data: Buffer.allocUnsafe(0)
          })
        }
      }
    }
  }

  /**
   * Function returning a `RequestHandler` given an incoming ILP Prepare.
   *
   * The default provider maintains a Map of handlers indexed by address prefixes. It finds the
   * handler that has the longest prefix that matches the `destination` of the incoming packet.
   */
  public handlerProvider: RequestHandlerProvider

  /**
   * The ILP address of this endpoint. Used in ILP Reject messages generated by the transport.
   */
  public address?: string

  public request (request: IlpPrepare, sentCallback?: (error?: Error) => void): Promise<IlpReply> {
    if (!this._client) throw new Error('underlying stream is not writeable')

    const timeoutMs = request.expiresAt.valueOf() - Date.now()
    if (timeoutMs > this._maxTimeoutMs || timeoutMs <= 0) {
      throw new SError('invalid expiresAt in ILP packet. timeoutMs=%s, maxTimeoutMs=%s', timeoutMs, this._maxTimeoutMs)
    }
    return new Promise<IlpReply>(async (replyCallback, errorCallback) => {
      const timeout = setTimeout(() => {
        // TODO - What to do with the request here?
        errorCallback(new SError('timed out waiting for response'))
      }, timeoutMs)

      try {
        const reply = await writeIlpHttpRequest(this._client, request, sentCallback)
        clearTimeout(timeout)
        replyCallback(reply)
      } catch (e) {
        errorCallback(e)
      }
    })
  }

  private _handleRequest (request: http.Http2ServerRequest, response: http.Http2ServerResponse): void {
    readIlpHttpRequest(request)
      .then(async (prepare) => {
        const handler = this.handlerProvider(prepare)

        let timedOut = false
        const timeout = setTimeout(() => {
          this.emit('error', new SError('timed out waiting for response from request handler. packet=%s', prepare))
          timedOut = true
        }, prepare.expiresAt.valueOf() - Date.now())

        handler(prepare)
        .then(reply => {
          if (timedOut) {
            this.emit('error', new SError('didn\'t send fulfill as prepare had already timed out. packet=%s', reply))
          } else {
            clearTimeout(timeout)
            try {
              writeIlpHttpResponse(response, reply)
            } catch (e) {
              this.emit('error', new SError(e, 'error sending fulfill. packet=%s', reply))
            }
          }
        })
        .catch(e => {
          // Error thrown by request handler
          const err = new SError(e, 'error handling incoming request. packet=%', prepare)
          this.emit('error', err)
          const reply = {
            triggeredBy: (this.address) ? this.address : 'peer',
            code: IlpErrors.codes.T00_INTERNAL_ERROR,
            message: '',
            data: Buffer.allocUnsafe(0)
          } as IlpReject
          try {
            writeIlpHttpResponse(response, reply)
          } catch (e) {
            this.emit('error', new SError(e, 'error sending reject. packet=%s', reply))
          }
        })
      }).catch(e => {
        this.emit('error', new SError(e, 'error reading request. request=%', request))
      })
  }
}

export async function writeIlpHttpRequest (client: http.ClientHttp2Session, request: IlpPrepare, sentCallback?: (error?: Error) => void): Promise<IlpReply> {
  if (sentCallback) sentCallback()
  return {
    fulfillment: Buffer.alloc(0),
    data: Buffer.alloc(0)
  }
}

// TODO - Based on content type, parse out the prepare packet
export async function readIlpHttpRequest (request: http.Http2ServerRequest): Promise<IlpPrepare> {
  return {
    amount: '',
    destination: '',
    executionCondition: Buffer.alloc(0),
    expiresAt: new Date(),
    data: Buffer.alloc(0)
  }
}

export function writeIlpHttpResponse (response: http.Http2ServerResponse, reply: IlpReply, sentCallback?: (error?: Error) => void): void {
  // TODO
  if (sentCallback) sentCallback()
  response.setHeader('content-type', '')
  response.write(reply.data, sentCallback)
}
